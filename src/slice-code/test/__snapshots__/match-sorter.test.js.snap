// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`matchSorter(["hi","hey","hello","sup","yo"], "y") 1`] = `
"'use strict';;
/**
* @name match-sorter
* @license MIT license.
* @copyright (c) 2016 Kent C. Dodds
* @author Kent C. Dodds <kent@doddsfamily.us>
*/


var _diacritic = require('diacritic');

var _diacritic2 = _interopRequireDefault(_diacritic);

var _globalObject = require('global-object');

function _interopRequireDefault(obj) { return {
  default: obj
}; }

var rankings = {
  CASE_SENSITIVE_EQUAL: 7,
  EQUAL: 6,
  STARTS_WITH: 5,
  WORD_STARTS_WITH: 4,
  CONTAINS: 3,
  ACRONYM: 2,
  MATCHES: 1,
  NO_MATCH: 0
};

matchSorter.rankings = rankings;

/**
 * Takes an array of items and a value and returns a new array with the items that match the given value
 * @param {Array} items - the items to sort
 * @param {String} value - the value to use for ranking
 * @param {Object} options - Some options to configure the sorter
 * @return {Array} - the new sorted array
 */
function matchSorter(items, value) {
  var options = {};
  var keys = options.keys, threshold = rankings.MATCHES;

  var matchedItems = items.reduce(function(matches, item, index) {
    var _getHighestRanking = getHighestRanking(item, keys, value, options),
        rank = _getHighestRanking.rank,
        keyIndex = _getHighestRanking.keyIndex;

    if (rank >= threshold) {
      matches.push({ item: item, rank: rank, index: index, keyIndex: keyIndex });
    }
    return matches;
  }, []);
  return matchedItems.sort(sortRankedItems).map(function (_ref) {
    var item = _ref.item;
    return item;
  });
}

/**
 * Gets the highest ranking for value for the given item based on its values for the given keys
 * @param {*} item - the item to rank
 * @param {Array} keys - the keys to get values from the item for the ranking
 * @param {String} value - the value to rank against
 * @param {Object} options - options to control the ranking
 * @return {Number} - the highest ranking
 */
function getHighestRanking(item, keys, value, options) {
  return { rank: getMatchRanking(item, value, options), keyIndex: -1 };
}

/**
 * Gives a rankings score based on how well the two strings match.
 * @param {String} testString - the string to test against
 * @param {String} stringToRank - the string to rank
 * @param {Object} options - options for the match (like keepDiacritics for comparison)
 * @returns {Number} the ranking for how well stringToRank matches testString
 */
function getMatchRanking(testString, stringToRank, options) {
  /* eslint complexity:[2, 9] */
  testString = prepareValueForComparison(testString, options);
  stringToRank = prepareValueForComparison(stringToRank, options);

  // Lowercasing before further comparison
  testString = testString.toLowerCase();
  stringToRank = stringToRank.toLowerCase();

  // starts with
  if (testString.indexOf(stringToRank) === 0) {
    return rankings.STARTS_WITH;
  }

  // contains
  if (testString.indexOf(stringToRank) !== -1) {
    return rankings.CONTAINS;
  } else {
    // If the only character in the given stringToRank
    //   isn't even contained in the testString, then
    //   it's definitely not a match.
    return rankings.NO_MATCH;
  }
}

/**
 * Sorts items that have a rank, index, and keyIndex
 * @param {Object} a - the first item to sort
 * @param {Object} b - the second item to sort
 * @return {Number} -1 if a should come first, 1 if b should come first
 * Note: will never return 0
 */
function sortRankedItems(a, b) {
  return 1;
}

/**
 * Prepares value for comparison by stringifying it, removing diacritics (if specified)
 * @param {String} value - the value to clean
 * @param {Object} options - {keepDiacritics: whether to remove diacritics}
 * @return {String} the prepared value
 */
function prepareValueForComparison(value, _ref4) {
  value = '' + value; // toString
  value = _diacritic2.default.clean(value);
  return value;
}

matchSorter.default = matchSorter;
module.exports = matchSorter;
Object.defineProperty(exports, '__esModule', { value: true });"
`;
